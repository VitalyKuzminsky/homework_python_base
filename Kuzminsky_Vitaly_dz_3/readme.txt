Приветствую, Анатолий.

task_3_1
Тут, вроде, всё ок. Инфу поместил в тело функции, т.к. это же она меняет значения слов.
Верно или нет? Например, в task_3_5 списки по заданию не в теле, чтобы с ними можно было
работать, давать разное наполнение.

task_3_2
Реализовал топорно, просто расширил словарь. Подозреваю задачка со * должна
решаться алгоритмами проверки первой буквы входящего аргумента или так допустимо?

task_3_3
Ответы на вопросы:
- полезен ли будет вам оператор распаковки?
Помимо входящего *args не использовал, но возможно это потому, что что-то
не так сделал в следующем пункте
- Как поступить, если потребуется сортировка по ключам?
Сортировку по ключам сделал - нужно раскомментировать сроки 14,20
- Можно ли использовать словарь в этом случае?
Сортировки, как я понял у dict нет, поэтому сортирую list, потом
возвращаю dict на выход

task_3_4
Тут по началу было достаточно просто выдернуть из аргументов фамилии и поместить
их в dict, потом отфильтровал по ключам, как в task_3_3.
Но в отличие от task_3_3 на вход и выход использовал разные dict, т.к. хотел
дальше перебрать значения, для выполнения задания, как требовалось в точности.
Но не могу понять, как мне перебрать значения словаря Букв фамилий, сделав из
них словарь Букв по именам.

task_3_5
С первой частью, считаю, справился. Тут просто перебираем count = n раз
глобальные переменные, выдергиваем случайный элемент из списков, лепим в строку,
собирая и возвращая списком.
Во второй части задания get_jokes_adv реализовал:
- документирование ф-ии, прошу прокомментировать - верно ли =)
- добавил именнованный элемент possible, он же является флагом. Default bool = True
что позволяет делать неограниченный набор шуток. Смена на False делает возможным
только один раз использовать каждое слово в шутке.
Есть одна тупость (в коде закоментил), где ф-ия, которой я проверяю минимальную длину
списков, из которых формируются "одноразовые" шутки, вызывается 2 раза, почти в одном месте:
1. сначала я делаю проверку, если пользователь задал кол-во шуток больше, чем позволяют
списки, то ограничиваю его, иначе программа упадёт, так как метод .pop() будет пробовать
вытащить новые слова из пустых списков.
2. второй раз приходится пробегать по этой функции, чтобы присвоить новое значение count.
Это глупо и затратно с точки зрения скорости работы кода.
Но как выйти из этого - не соображу.
Еще одна задача функции check_min_len проверить, какое вообще кол-во раз можно генерировать
"одноразовые" шутки, так как при разной длине глобальных объектов списков nouns, adverbs,
adjectives программа опять же ляжет.